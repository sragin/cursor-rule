---
globs: *.py
alwaysApply: false
---
# Python 개발 규칙

## 🐍 Python 코딩 스타일

### 기본 규칙
- [ ] PEP 8 스타일 가이드 준수
- [ ] 적절한 들여쓰기 (4칸 공백)
- [ ] 의미있는 변수명과 함수명 사용
- [ ] 한 줄당 최대 79자 제한
- [ ] 클래스명은 CamelCase, 함수명은 snake_case

### 임포트 규칙
- [ ] 표준 라이브러리 먼저 임포트
- [ ] 서드파티 라이브러리 그 다음
- [ ] 로컬 애플리케이션/라이브러리 마지막
- [ ] 각 그룹 사이에 빈 줄 추가
- [ ] 사용하지 않는 임포트 제거

### 문서화
- [ ] 모든 함수와 클래스에 docstring 작성
- [ ] 복잡한 로직에 인라인 주석 추가
- [ ] TODO, FIXME, NOTE 태그 활용
- [ ] 타입 힌트 사용 권장

## 🔧 프로젝트 특화 규칙



## 🧪 테스트 규칙

### 테스트 작성 체크리스트
- [ ] 반드시 PYTEST 사용
- [ ] 각 기능별 단위 테스트 작성
- [ ] 모킹을 활용한 외부 의존성 격리
- [ ] 예외 상황 테스트 케이스 포함
- [ ] 테스트 커버리지 80% 이상 유지
- [ ] 테스트 실행 시간 최적화

### 테스트 파일 명명 규칙
- 테스트 파일: `test_*.py`
- 테스트 클래스: `Test*`
- 테스트 메서드: `test_*`

## 🚀 성능 최적화

### 메모리 관리
- [ ] 큰 데이터셋 처리 시 제너레이터 활용
- [ ] 불필요한 객체 참조 제거
- [ ] 컨텍스트 매니저 사용 (with 문)
- [ ] 메모리 누수 방지를 위한 적절한 리소스 해제

### 실행 성능
- [ ] 반복문 내 불필요한 연산 최소화
- [ ] 적절한 자료구조 선택
- [ ] 캐싱 전략 활용
- [ ] 비동기 처리 고려

## 🔍 디버깅 가이드

### 로깅 규칙
- [ ] 적절한 로그 레벨 사용 (DEBUG, INFO, WARNING, ERROR)
- [ ] 구조화된 로그 메시지 작성
- [ ] 민감한 정보 로깅 금지
- [ ] 로그 로테이션 설정

### 디버깅 도구
- [ ] pdb 또는 ipdb 사용
- [ ] print 디버깅 대신 로깅 활용
- [ ] 프로파일링 도구 활용 (cProfile, line_profiler)
- [ ] 메모리 프로파일링 (memory_profiler)

## 📦 의존성 관리

### requirements.txt 관리
- [ ] 버전 고정 (== 사용)
- [ ] 보안 취약점이 있는 패키지 업데이트
- [ ] 사용하지 않는 의존성 제거
- [ ] 정기적인 의존성 검토

### 가상환경
- [ ] 프로젝트별 가상환경 사용
- [ ] conda 환경 설정 파일 관리
- [ ] 환경 변수 설정 (.env 파일 활용)

## 🛡️ 보안 규칙

### 입력 검증
- [ ] 모든 사용자 입력 검증
- [ ] SQL 인젝션 방지 (파라미터화된 쿼리)
- [ ] 파일 업로드 시 확장자 및 크기 제한
- [ ] 민감한 정보 암호화

### 네트워크 보안
- [ ] HTTPS 사용 권장
- [ ] API 키 및 토큰 안전한 저장
- [ ] 네트워크 통신 시 타임아웃 설정
- [ ] SSL/TLS 인증서 검증

## 📚 참고 자료

### 프로젝트 파일
- 메인 실행 파일: [main.py](mdc:main.py)
- 의존성 목록: [requirements.txt](mdc:requirements.txt)
- 환경 변수 예시: [env.example](mdc:env.example)

### 테스트 파일
- 테스트 디렉토리: [test/](mdc:test/)
